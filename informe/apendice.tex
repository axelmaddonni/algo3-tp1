\subsection{Demostración del Lema 3.1}

Vamos a demostrar que $T(n) = F(n)$, si $n=2k$ con $k\in\mathbb{N}$, por inducción en $k$.

\textbf{Caso base:} $k=0 \implies n=0$

  $T(0) = 1$ 

  Dado que las sumatorias y las productorias en las que el límite inferior es más grande que el superior se devuelve el elemento neutro para la suma y el producto, 0 y 1 respectivamente, tenemos que $F(0) = 1$. Entonces demostramos el caso base.

\textbf{Paso inductivo:} Supongamos que $T(n) = F(n)$. Veamos que también vale $T(n + 2) = F(n + 2)$ \\
  \begin{equation}
  \label{eq:ind3-1}
  \begin{aligned}
  T(n+2) &= (n+2)^3 + (n+2)^2 T(n) \\
         &= (n+2)^3 + (n+2)^2 F(n) \\
         &= (n+2)^3 + (n+2)^2 \sum_{i=0}^{\frac{n}{2}-1} \left((n-2i) \prod_{j=0}^{i}(n-2j)^2\right) + (n+2)^2 \prod_{i=0}^{\frac{n}{2}-1}(n-2i)^2\\
         &= (n+2)^3 + \sum_{i=0}^{\frac{n}{2}-1} \left((n-2i) (n+2)^2 \prod_{j=0}^{i}(n-2j)^2\right) + (n+2)^2 \prod_{i=0}^{\frac{n}{2}-1}(n-2i)^2
  \end{aligned}
  \end{equation}

  Por otro lado tenemos

  $F(n+2) = \sum_{i=0}^{\frac{n}{2}} \left((n+2-2i) \prod_{j=0}^{i}(n+2-2j)^2\right) + \prod_{i=0}^{\frac{n}{2}}(n+2-2i)^2$

  Ahora hagamos un par de observaciones:

  \begin{equation}
  \label{eq:ind3-2}
  \begin{aligned}
  (n+2)^2 \prod_{j=0}^{i}(n-2j)^2
  &= (n+2)^2 \prod_{t=1}^{i+1}(n-2(t-1))^2\\
  &= (n+2)^2 \prod_{t=1}^{i+1}(n+2-2t))^2\\
  &= \prod_{t=0}^{i+1}(n+2-2t)^2 
  \end{aligned}
  \end{equation}

  \begin{equation}
  \label{eq:ind3-3}
  \begin{aligned}
  (n+2)^3 + \sum_{i=0}^{\frac{n}{2}-1} \left((n-2i) \prod_{t=0}^{i+1}(\hdots)\right)
  &= (n+2)^3 + \sum_{r=1}^{\frac{n}{2}} \left((n-2(r-1)) \prod_{t=0}^{r}(\hdots)\right) \\
  &= (n+2)^3 + \sum_{r=1}^{\frac{n}{2}} \left((n+2-2r)) \prod_{t=0}^{r}(\hdots)\right) \\
  &= \sum_{r=0}^{\frac{n}{2}} \left((n+2-2r)) \prod_{t=0}^{r}(\hdots)\right)
  \end{aligned}
  \end{equation}

  Notar que la igualdad \ref{eq:ind3-2} puede instanciarse para $i = \frac{n}{2}-1$. 
  Aplicando las igualdades \ref{eq:ind3-2} (dos veces) y \ref{eq:ind3-3} sobre la ecuación \ref{eq:ind3-1}, llegamos a que $T(n + 2) = F(n + 2)$. $\qed$


\subsection{Kamehameha: el caso promedio se parece al peor caso}

Formalicemos que queremos decir con esto. Supongamos que los puntos de nuestro \emph{input} provienen, al azar, del conjunto $\mathcal{X}_M = \{1, \cdots., M\} \times \{1, \cdots, M\}$. Lo que probaremos aquí es que si M es grande, entonces la probabilidad de que necesitemos $\frac{n}{2}$ rectas para cubrir todos los puntos (peor caso) es alta.

Primero, calculemos la cantidad de formas de elegir $n$ puntos de ese conjunto:

\[|\{\text{formas de elegir $n$ puntos de $\mathcal{X}_M$} \}| = \binom{M^2}{n} = \frac{M^2 (M^2 - 1) (M^2 - 2) (M^2 - 3) \dots (M^2 - n + 1)}{n!}\]

Por otro lado, contemos las configuraciones en las que necesitamos menos de $\frac{n}2$ semirrectas para cubrir todos los puntos. Estas configuraciones obviamente están incluidas (de hecho son iguales) a las configuraciones en las que hay (al menos) 3 puntos alineados.

\[|\{\text{formas de elegir $n$ puntos de $\mathcal{X}_M$ tal que haya 3 alineados}\}| \leq \frac{M^2 (M^2 - 1) n (M^2 - 3) \dots (M^2 - n + 1)}{n!}\]

Esta fórmula vale porque $M^2 (M^2 - 1)$ son las formas de elegir los primeros 2 puntos. Luego tengo, como máximo, $n$ puntos que puedo elegir sobre la semirrecta formada por los primeros 2 puntos. Finalmente, elijo los $n - 3$ puntos restantes como quiera. Divido por $n!$ para eliminar las permutaciones.

Ahora, calculemos la probabilidad de que, dada una configuración al azar, esta requiera menos de $\frac{n}2$ semirrectas para cubrir todos los puntos. Llamaremos a esta probabilidad $p$.

\[p \leq \frac{|\{\text{formas de elegir $n$ puntos de $\mathcal{X}_M$ tal que haya 3 alineados} \}|}{|\{\text{formas de elegir $n$ puntos de $\mathcal{X}_M$} \}|} \leq \frac{n} {M^2 - 2}\]


Entonces, si tomamos los puntos sobre $\mathbb{N}^2$, como el problema indica y queremos calcular la probabilidad $p$, basta con hacer tender $M$ a $\infty$, que se ve claramente que tiende a 0.

Más aún, en nuestros casos experimentales, elegimos $M = n^2$, por lo tanto queda que

\[p \leq \frac{n} {n^2 - 2} \to 0\]

Confirmando formalmente lo observado experimentalmente.

\newpage
\subsection{Partes relevantes del código}
\lstset{language=C++, breaklines=true, basicstyle=\footnotesize}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, tabsize=2}

\subsubsection{kaioken1.cpp}
\begin{lstlisting}[frame=single]
void generarpeleas(int n, int pactual, int inicio,
                   vector<vector<int>> &matrizpeleas){
  if (n == 1) {
    // El caso n = 1 es trivial.
    matrizpeleas[pactual][inicio] = 1;
  } else if (n == 2) {
    // El caso n = 2 es trivial.
    matrizpeleas[pactual][inicio] = 1;
    matrizpeleas[pactual][inicio+1] = 2;
  } else {
    // Nos aseguramos de que las dos partes peleen entre si.
    for (int j=0; j< n; j++) {
      if (j < n/2) {
        matrizpeleas[pactual][inicio + j] = 1;
      } else {
        matrizpeleas[pactual][inicio + j] = 2;
      }
    }
    // Resolvemos el subproblema para cada mitad.
    generarpeleas(n / 2, pactual+1, inicio, matrizpeleas);
    generarpeleas((n + 1) / 2, pactual+1, n/2 + inicio, matrizpeleas);
  }
}

void kaioken (int n){
  int cpeleas = ceil(log2(n));
  cout << cpeleas << endl;

  if (n == 1) {
    // Si hay 1 solo guerrero, el problema ya esta resuelto.
    return;
  } else if (n == 2) {
    cout << 1 << " " << 2 << endl;
  } else {
    vector<vector<int>> matrizpeleas(cpeleas, vector<int>(n,1));
    int pactual = 0;
    for (int i = 0; i < n; i++) {
      if (i < n/2) {
        matrizpeleas[pactual][i] = 1;
      } else {
        matrizpeleas[pactual][i] = 2;
      }
    }

    generarpeleas(n / 2, pactual+1, 0, matrizpeleas);
    generarpeleas((n + 1) / 2, pactual+1, n/2, matrizpeleas);

    // Imprimo la matriz
    for (int i = 0; i < cpeleas; i++) {
      for (int j = 0; j < n; j++) {
        cout << matrizpeleas[i][j];
        if (j != n-1) cout << " ";
      }
      cout << endl;
    }
  }
} 
\end{lstlisting}

\subsubsection{genkidama2.cpp}

\begin{lstlisting}[frame=single]
vector<int> solve(vector<pair<int, int>> puntos, int t) {
  int n = puntos.size();
  int i = 0;  // a quien le disparo
  int j = 0;  // primero a matar
  vector<int> res;
  while (j < n) {
    i = j;    
    // Elijo al ultimo el elemento que sirve para abarcar todos hasta el primero.
    while (i < n - 1 &&
           puntos[i+1].first + t >= puntos[j].first) {
      i++;
    }
    res.push_back(i + 1);
    i++;
    j = i;
    // Avanzo todos los elementos que abarcamos.
    while (j < n  && puntos[j].second <= puntos[i-1].second + t) {
      j++;
    }
  }
  return res;
}
\end{lstlisting}

\subsubsection{kamehameha3.cpp}

\begin{lstlisting}[frame=single]
int mejor;
vector<vector<int>> mejor_sol;
std::vector<pair<int, int>> puntos;
int n;

void backtracking(Tablero t, int s) {
  if(s >= mejor)
    return;  // El subarbol no es aceptable.
  else if(t.Solucionado()) {
    mejor = s;
    mejor_sol = t.Solucion();
  } else {
    // Elegimos un vivo.
    for (int i = 0; i < n; i++) {
      if (t.EstaVivo(i)) {
        if (t.Vivos() == 1) {
          vector<int> derrotados;
          derrotados.push_back(i);
          t.Matar(derrotados);
          backtracking(t, s+1);
          break;
        }
        // Elegimos otro vivo.
        for (int j = 0; j < n; j++) {
          if(j != i && t.EstaVivo(j)){
            Tablero sucesor(t);
            std::vector<int> derrotados;
            derrotados.push_back(i);
            derrotados.push_back(j);
            derrotados.reserve(n);
            double x_i = puntos[i].first;
            double y_i = puntos[i].second;
            double x_j = puntos[j].first;
            double y_j = puntos[j].second;
            // Eliminamos todos los elementos que pertenecen a esa semirrecta.
            for (int k = 0; k < n; k++) {
              if(k != i && k != j && t.EstaVivo(k)) {
                double x_k = puntos[k].first;
                double y_k = puntos[k].second;
                if (x_i != x_j && y_i != y_j) {
                  double cociente_x = (x_k - x_i) / (x_j - x_i); 
                  double cociente_y = (y_k - y_i) / (y_j - y_i); 
                  if (cociente_x == cociente_y &&
                      mismo_cuadrante(puntos[i], puntos[j], puntos[k]))
                    derrotados.push_back(k);
                } else {
                  bool al_vertical = (x_k == x_i && x_k == x_j);
                  bool al_horizontal = (y_k == y_i && y_k == y_j);
                  if ((al_vertical || al_horizontal) &&
                      mismo_cuadrante(puntos[i], puntos[j], puntos[k]))
                    derrotados.push_back(k);
                }
              }
            }
            // Eliminamos de la lista a los elementos cubiertos por la semirrecta, y llamamos a la funcion recursivamente para cubrir al resto de los puntos.
            sucesor.Matar(derrotados);
            backtracking(sucesor, s+1);
            // Si el mejor = s+1 no vale la pena seguir iterando, porque cualquier solucion que encontremos va a ser a lo sumo tan buena como la que tenemos.
            if (mejor == s+1) return;
          }
        }
      }
    }
  }
}
\end{lstlisting}